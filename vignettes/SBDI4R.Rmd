---
title: "Introduction to SBDI4R"
author: "Alejandro Ruete and Debora Arlt"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    fig_caption: TRUE
vignette: >
  %\VignetteIndexEntry{Introduction to SBDI4R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(knitr)
opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(width = 120)
```  

Here we provide a collection of use-examples showing examples for a range of queries that we think a typical use of the biodiversity infrastructure may want to perform. The examples are extended from a basic set for ALA4R presented at the [2014 ALA Science Symposium](http://www.ala.org.au/blogs-news/2014-atlas-of-living-australia-science-symposium/). 

The SBDI4R package is primarily for accessing data. It includes some filter functions that allow you to filter prior to download. It also includes some simple summary functions, and some function for some simple data exploration. The examples also show you how you can use the data by continued exploring and analysing using other R package.

Please get in contact with us if you have questions regarding the use of the SBDI4R package.

## Using SBDI4R

Lets assume you have already installed the package as shown in the main site \url{https://biodiversitydata-se.github.io/SBDI4R}. 

The SBDI4R package must be loaded for each new R session:
```{r, message=FALSE}
library(SBDI4R)
sbdi_config(caching="off")
```  

However, the options you stored in .Rprofile if you did it so, will load automatically 
with the package. Then, check that we have some additional packages that we'll 
use in the examples, and install them if necessary.
```{r, message=FALSE}
to_install <- c("ape", "dplyr", "ggplot2", "jpeg", "leaflet","maps", "mapdata",
                "maptools", "phytools", "sp", "rgeos", "tidyr", "vegan")
to_install <- to_install[!sapply(to_install, requireNamespace, quietly=TRUE)]
if(length(to_install)>0)
    install.packages(to_install, repos="http://cran.us.r-project.org")
```


## Example 1: Name searching and taxonomic trees
We want to look at the taxonomy of titmice, but we don’t know what the correct 
scientific name is, so let’s search for it:
```{r, warning=FALSE, message=FALSE}
sx <- search_fulltext("parus")
sx$data[,c( "name","species", "speciesGuid", "rank")]
```  

But we see some e.g. insects (**Neuroctenus parus**) are also returned. We want to restrict the search to Paridae.
```{r, message=FALSE}
sx <- search_fulltext("parus", fq="family_s:Paridae")
sx$data[,c( "name","species", "speciesGuid", "rank")]
```
To restrict the query specifically to birds we can also use the 'fq' argument to filter the query (see \code{sbdi_fields("general", as_is=TRUE)} for all the fields that are queryable), and increase page_size to include more records (default=10):
```{r, message=FALSE}
sx <- search_fulltext("parus", fq="class_s:Aves", page_size=100)
sx$data[,c( "name","species", "speciesGuid", "rank")]
```

Now we can download the taxonomic data (note that the search is case-sensitive):
```{r, message=FALSE}
tx <- taxinfo_download("family_s:Paridae", 
                       fields=c("guid", "genus_s", "scientificName", "rank"))
tx <- tx[tx$rank == "species",] ## restrict to species
```
We can make a taxonomic tree plot using the `phytools` package:
```{r, message=FALSE}
library(phytools)
## as.phylo requires the taxonomic columns to be factors
tx$genusS <- as.factor(tx$genusS)
tx$scientificName <- as.factor(tx$scientificName)
## create phylo object of Scientific.Name nested within Genus
ax <- as.phylo(~genusS/scientificName, data=tx)
plotTree(ax, fsize=0.7, ftype="i") ## plot it
```

## Example 2: Get some data, quality assertions, plotting data on a map and save data

Download occurrence data for the "Sommarlånke" and view top of 
the data table:
```{r, message=FALSE}
x <- occurrences(taxon="Callitriche cophocarpa", 
                 email="test@test.org", 
                 download_reason_id=10)
head(x$data)
table(x$data$dataResourceName)

#keep spatially unique data at 0.01 degrees (latitude and longitude)
# ll <- unique(x, spatial=0.01)
# summary(ll)
# 
# #keep only information for which fatal or "error" assertions do not exist
# nofat <- subset(x, remove.fatal = TRUE)
# summary(nofat)
# 
# #keep only information for which fatal or "error" assertions do not exist
# 
# SpatCert <- subset(x, max.spatial.uncertainty=50)
# summary(SpatCert)
# # # quickly get some more info about the data:
# 
# # no. observations (records)
# nrow(x$data)
# 
# # no. obs/year
# table(x$data$year) 
# freq_year <- table(x$data$year)
# #sum(freq_year)
# 
# # data where 'year' is missing?
# sum(is.na(x$data$year))
# 
# 
# # no. obs across years:
# hist(x$data$year, 20)
# 
# library(plyr)
# #count(x$data$year)
# c <- count(x$data$year)
# barplot(c$freq ~ c$x)
# 
# 
# # subsetting
# 
# # get occurrences for selected time
# 
# # year = 2019
# x2019 <- occurrences(taxon="Reynoutria japonica", fq="year:2019")
# nrow(x2019$data) 
# 
# x2yr <- occurrences(taxon="Reynoutria japonica", fq=c("year:2018 OR year:2019"))
# nrow(x2yr$data) 
# 
# 
# # years 2010 - 2019:
# ##current alternative is downloading all and filter afterwards
# x <- occurrences(taxon="Reynoutria japonica")
# x10yr <- x$data[(x$data$year>=2010 & x$data$year<=2019),] 
# table(x10yr$year)
```

We see there are different data sources. Let´s assume you only need to see data from one source, e.g. Artportalen. If you see on the data that Artportalens identifier is "dr5" you can directly filter the search by:
```{r, message=FALSE}
xf <- occurrences(taxon="Callitriche cophocarpa", 
                 fq = "data_resource_uid:dr5",
                 email="test@test.org", 
                 download_reason_id=10)
table(xf$data$dataResourceName)
```
Else, you can search available data resourses, collections (and more) using the interactive function \code{pick_filter} like:
```{r, message=FALSE, eval= FALSE}
fq_str <- pick_filter("resource") 
## follow the instructions

x <- occurrences(taxon="Callitriche cophocarpa", 
                 fq = fq_str,
                 email="test@test.org", 
                 download_reason_id=10)
table(x$data$dataResourceName)
```

### Quality assertions
Data quality assertions are a suite of fields that are the result of a set of tests performed on data. We continue using the data for the Blunt-fruited Water-starwort and get a summary of the data quality assertions:
```{r, message=FALSE}
summary(x)
```  

You can see a list of all record issues using `sbdi_fields("assertions",as_is=TRUE)` and see what is considered as fatal quality issues.

### Plotting data on a map  
You can quickly plot all the observations with the function `ocurrence_plot()`, here we specify to map all fatal issues:
```{r}
occurrences_plot(x, "obsPlot.pdf", qa="fatal", 
                  grouped=FALSE, taxon_level="species", 
                  pch='+')
```
Note that the plot is saved to a pdf file in the current working directory. You can find that by `getwd()`.  

<img src=https://github.com/biodiversitydata-se/SBDI4R/blob/master/man/figures/obsPlot_CallitricheCophocarpa.png />

There are many other ways of producing spatial plots in R. The `leaflet` package provides a simple method of producing browser-based maps with panning, zooming, and background layers:
```{r}
library(leaflet)
## drop any records with missing lat/lon values
x$data <- x$data[!is.na(x$data$longitude) & !is.na(x$data$latitude),] 
xa <- check_assertions(x)
## columns of x corresponding to a fatal assertion
x_afcols <- which(names(x$data) %in% xa$occurColnames[xa$isFatal])
## rows of x that have a fatal assertion
x_afrows <- apply(x$data[,x_afcols], 1, any)
## which taxonIdentificationIssue assertions are present in this data?
these_assertions <- names(x$data)[x_afcols]
## make a link to the web page for each occurrence
popup_link <- paste0("<a href=\"https://records.bioatlas.se/occurrences/",
                      x$data$id,"\">Link to occurrence record</a>")
## colour palette
pal <- c(sub("FF$","", heat.colors(length(these_assertions))))
## map each data row to colour, depending on its assertions
marker_colour <- rep("#00FF00", nrow(x$data))
if(length(these_assertions)>0){
  for (k in 1:length(these_assertions)){
    marker_colour[x$data[,x_afcols[k]]] <- pal[k]
  } 
}
## blank map, with imagery background
m <- addProviderTiles(leaflet(),"Esri.WorldImagery")
## add markers
m <- addCircleMarkers(m, x$data$longitude, x$data$latitude,  radius = 5,
                      col=marker_colour, popup=popup_link)
m
```  

### Save data
```{r}
# save as data.frame
Callitriche <- as.data.frame(x$data)

# simplyfy data frame
calli <- data.frame(Callitriche$scientificName,
                   Callitriche$latitude,
                   Callitriche$longitude)
# simplify column names
colnames(calli) <- c("species","latitude","longitude")
# remove rows with missing values (NAs)
calli <- na.omit(calli)

# save new dataframe
write.csv(calli,"Callitriche.csv")
```

## Example 3: Summarise occurrences over a defined grid

Now, following with the data downloaded in the previous example, we want to 
summarise occurrences over a defined grid instead of plotting every observation 
point. First we need to overlay the observations with the grid:  

```{r, message=FALSE}
library(sp) # the function coordinates() and proj4string() are in sp
library(rgeos) #  the function over() is in package rgeos
## load some shapes over Sweden
data("swe_wgs84", package="SBDI4R", envir=environment()) # Political borders
data("swe100kmGrid", package="SBDI4R", envir=environment()) # A grid
grid <- swe100kmGrid
grid <- spTransform(grid, CRS("+init=epsg:4326")) ## it has the same CRS 
# but changes are undergoing in the sp package and this step is needed

## make the observations spatial
obs <- as.data.frame(x$data)
coordinates(obs) <- obs[,c("longitude","latitude")]
proj4string(obs) <- CRS("+init=epsg:4326")

nObs <- nrow(obs)

## overlay the data with the grid
ObsInGridList <- over(grid, obs, returnList=TRUE)
wNonEmpty <- unname( which( unlist(lapply(ObsInGridList, nrow)) != 0) )
if(length(wNonEmpty)==0) message("Observations don't overlap any grid cell.")

## check nObs
nObsInGrid <- sum(unlist(lapply(ObsInGridList, nrow)))
```

### Summarise
Now summarise occurrences within grid cells:
```{r}
## apply a summary over the grid
nCells <- length(ObsInGridList)

res <- data.frame("nObs"=as.numeric(rep(NA,nCells)),
                  "nYears"=as.numeric(rep(NA,nCells)),
                  stringsAsFactors = FALSE)

cols2use <- c("scientificName", "year")

dataRes <- lapply(ObsInGridList[wNonEmpty], function(x){
  x <- x[,cols2use]
  colnames(x) <- c("scientificName", "year")
  
  return(c("nObs" = length(x[,"scientificName"]),
           "nYears" = length(unique(x[,"year"]))
  ))
})

dataRes <- data.frame(matrix(unlist(dataRes),
                             nrow=length(dataRes), 
                             byrow=TRUE),
                    stringsAsFactors = FALSE)

dataRes$X1 <- as.numeric(dataRes$X1)
dataRes$X2 <- as.numeric(dataRes$X2)

res[wNonEmpty,] <- dataRes
rownames(res) <- row.names(grid)

resSp <- sp::SpatialPolygonsDataFrame(grid, res)
```  

### Plotting data on a map
Finally plot the grid summary as a map:
```{r, fig.width=6, fig.height=6}
palBW <- leaflet::colorNumeric(c("white", "navyblue"), 
                               c(0, max(resSp@data$nObs, na.rm = TRUE)), 
                               na.color = "transparent")
plot(resSp, col=palBW(resSp@data$nObs), border = NA)
plot(swe_wgs84$Border, border=1, lwd=1, add=T)
legend("bottomleft", 
       legend = round(seq(0, max(resSp@data$nObs, na.rm = TRUE), length.out = 5)),
       col = palBW(seq(0, max(resSp@data$nObs, na.rm = TRUE), length.out = 5)),
       title = "Number of \nobservations", pch = 15, bty="n")
```

## Example 4: Area report: what listed species exist in a given area?

Vector spatial layers (eg. Polygons) can be imported  in a number of different ways. 
Bioatlas' APIs take as search input polygons in the s.k. WKT (Well Known Text \url{https://www.geoapi.org/3.0/javadoc/org/opengis/referencing/doc-files/WKT.html}). 
So the first step is to load a vector layer and transform it into a WKT string. 
First download a .zip file with different delimitations for Sweden \url{https://www.scb.se/hitta-statistik/regional-statistik-och-kartor/regionala-indelningar/digitala-granser}
and move it somewhere you like in your computer. We recommend you move it into your 
working directory (\code{getwd()}). Extract the .zip file named KommunSweref99.zip.
<!-- We use the ALA4R's caching mechanism here, but you could equally download this file directly. -->

```{r, eval=FALSE}
library(rgdal)
shape <- readOGR(dsn=file.path("your/path/to/file", "Kommun_Sweref99TM_region.shp"))
```
This will only work when you set a valid filepath, and will create an object of 
class SpatialPolygon. You could instead use the data we kindly provided in this 
package \code{data("swe")} 

```{r}
shape <- swe$Municipalities
## extract just the Municipality of Örebro
shape <- shape[shape$KnNamn=="Örebro", ]
```

We could create the WKT string using the `rgeos` library:
```{r eval=FALSE}
library(rgeos)
wkt <- writeWKT(shape)
```

Unfortunately, in this instance this gives a WKT string that is too long and won't
be accepted by the web service. Also, the shapefile we just got is projected in 
the coordinate system SWEREF99 TM, and the web service only accepts coordinates in 
a geodesic coordinate system WGS84. Instead, let's construct the WKT string directly, 
which gives us a little more control over its format:
```{r}
library(sp)
shape <- spTransform(shape, CRSobj = CRS("+init=epsg:4326")) ## the magic number for WGS84
lonlat <- shape@polygons[[1]]@Polygons[[1]]@coords ## extract the polygon coordinates
## extract the convex hull of the polygon to reduce the length of the WKT string
temp <- chull(lonlat)
lonlat <- lonlat[c(temp, temp[1]), ]
## create WKT string
## first join each lon-lat coordinate pair
temp <- apply(lonlat, 1, function(z) paste(z, collapse=" "))
## now build the WKT string
wkt <- paste("POLYGON((", paste(temp, collapse=","), "))", sep="")
```

Now extract the species list in this polygon:
```{r eval=FALSE}
specieslist(wkt=wkt) %>%
    dplyr::arrange(desc(occurrenceCount)) %>%
    dplyr::select(speciesName, species, family, occurrenceCount) %>%
    head(10)
```

```{r message=FALSE}
tryCatch({
specieslist(wkt=wkt) %>%
    dplyr::arrange(desc(occurrenceCount)) %>%
    dplyr::select(speciesName, species, family, occurrenceCount) %>%
    head(10)
}, error = function(e) { print(e$message)})
```

## Example 5: Community composition and turnover

```{r message=FALSE}
library(vegan)
```

Define our area of interest as a transect running westwards from the Stockholm region, and download the occurrences of legumes (Fabaceae; a large family of flowering plants) in this area:  
```{r eval=FALSE}
wkt <- "POLYGON((14.94 58.88, 14.94 59.69, 18.92 59.69, 18.92 58.88, 14.94 58.88))"

## define some environmental layers of interest [see sbdi_fields(fields_type = "occurrence")]
# el10011 https://spatial.bioatlas.se/ws/layers/view/more/worldclim_bio_12
# el10009 https://spatial.bioatlas.se/ws/layers/view/more/worldclim_bio_10
env_layers <- c("el10009","el10011") 
## Download the data.  We use the `occurrences()` function, adding environmental
## data via the 'extra' parameter. 
x <- occurrences(taxon="family:Fabaceae", wkt=wkt, qa="none",
                 download_reason_id="testing", extra=env_layers)
```

Convert this to a sites-by-species data.frame:
```{r eval=FALSE}
xgridded <- x$data %>%
    ## discard genus- and higher-level records
    dplyr::filter(rank %in%
                  c("species", "subspecies", "variety", "form", "cultivar")) %>%
    ## bin into 0.5-degree bins
    mutate(longitude=round(longitude*2)/2, 
           latitude=round(latitude*2)/2, 
           worldClimMeanTemperatureOfWarmestQuarter = worldClimMeanTemperatureOfWarmestQuarter /10) %>%
    ## average environmental vars within each bin
    group_by(longitude,latitude) %>%
    mutate(worldClimAnnualPrecipitation = mean(worldClimAnnualPrecipitation, na.rm=TRUE),
           worldClimMeanTemperatureOfWarmestQuarter = mean(worldClimMeanTemperatureOfWarmestQuarter, na.rm=TRUE)) %>%
    ## subset to vars of interest
    dplyr::select(longitude, latitude, species, 
                  worldClimAnnualPrecipitation,
                  worldClimMeanTemperatureOfWarmestQuarter) %>%
    ## take one row per cell per species (presence)
    distinct() %>%
    ## calculate species richness
    mutate(richness=n()) %>%
    ## convert to wide format (sites by species)
    mutate(present=1) %>%
    do(tidyr::spread(data=., key=species, value=present, fill=0)) %>%
    ungroup()
## where a species was not present, it will have NA: convert these to 0
sppcols <- setdiff(names(xgridded),
                   c("longitude", "latitude", 
                     "worldClimAnnualPrecipitation", 
                     "worldClimMeanTemperatureOfWarmestQuarter",
                     "richness"))
xgridded <- xgridded %>% mutate_at(sppcols, function(z) ifelse(is.na(z), 0, z))
```

```{r include=FALSE}
## load data from a local copy so that vignette building doesn't require downloading a big chunk of data and slow sites-by-species processing
## this file generated by running the above unevaluated code blocks, then
## saveRDS(xgridded, file="vignette_fabaceae.rds")
xgridded <- readRDS("vignette_fabaceae.rds")
sppcols <- setdiff(names(xgridded), c("longitude", "latitude", 
                                      "worldClimAnnualPrecipitation", 
                                      "worldClimMeanTemperatureOfWarmestQuarter", 
                                      "richness"))
```

The end result:
```{r}
xgridded
```

Now we can start to examine the patterns in the data. Let's plot richness as a function of longitude:
```{r warning=FALSE}
library(ggplot2)
ggplot(xgridded, aes(longitude, richness)) + 
  geom_point() + 
  theme_bw()

```
<!-- We see outliers in species richness that may be solved if names and synonyms are curated -->
<!-- as.data.frame(xgridded[xgridded$richness>200,]) -->

Species richness as a function of environment:
```{r warning=FALSE}
ggplot(xgridded, aes(worldClimMeanTemperatureOfWarmestQuarter , 
                     worldClimAnnualPrecipitation, 
                     colour=richness)) +
  scale_colour_distiller(palette="Spectral") +
  geom_point(size=8) + 
  theme_bw()
```

Higher species richness in hottest areas.

How does the community composition change along the transect? Use clustering:

```{r fig.width=6, fig.height=6}
library(vegan)
## Bray-Curtis dissimilarity
D <- vegdist(xgridded[, sppcols], "bray")
## UPGMA clustering
cl <- hclust(D, method="ave")
## plot the dendrogram
plot(cl)
## extract group labels at the 20-group level
grp <- cutree(cl, 20)
## coalesce small (outlier) groups into a single catch-all group
sing <- which(table(grp)<5)
grp[grp %in% sing] <- 21 ## put these in a new combined group
grp <- sapply(grp, function(z)which(unique(grp)==z)) ## renumber groups
xgridded$grp <- as.factor(grp)
## plot
## colours for clusters
thiscol <- c("#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2",
             "#7f7f7f", "#bcbd22", "#17becf")
ggplot(xgridded, aes(longitude, latitude, colour=grp)) + 
  geom_point(size=5) +
  scale_colour_manual(values=thiscol) + 
  theme_bw()
## or a slightly nicer map plot
library(maps)
library(mapdata)
map("worldHires", "Sweden", 
    # xlim=c(105, 155), ylim=c(-45, -10), 
    col="gray90", fill=TRUE)
with(xgridded, points(longitude, latitude, pch=21, col=thiscol[grp], bg=thiscol[grp], cex=0.75))
```


<!-- data_resources() NOT YET IMPLEMENTED -->
<!-- ### Example 6: Retrieve assertion information for datasets -->
<!-- Compare data quality metrics for data resources -->
<!-- ```{r} -->
<!-- dr <- data_resources(druid = c('dr1411','dr90','dr361'), extra = 'assertions') -->
<!-- ``` -->

<!-- ```{r eval = FALSE} -->
<!-- # View names of all columns returned -->
<!-- names(dr) -->
<!-- ``` -->

<!-- Extract the assertion metrics from the dataset -->
<!-- ```{r warning = FALSE} -->
<!-- library(tidyr) -->
<!-- # match cols against known assertions -->
<!-- assertions <- ala_fields('assertions') -->
<!-- assert_match <- names(dr)[names(dr) %in% assertions$name] -->
<!-- dr_assert <- dr %>% select(uid, all_of(assert_match)) %>% -->
<!--   pivot_longer(-uid, names_to = "assertion", values_to = "count") %>% -->
<!--   mutate(count = as.integer(trimws(as.character(count)))) %>% -->
<!--   # build axes labels with readable assertions -->
<!--   mutate(assertion_label = tolower(gsub('([A-Z])','\n\\1',assertion))) -->
<!-- ``` -->

<!-- Plot the assertions -->
<!-- ```{r warning=FALSE} -->
<!-- library(ggplot2) -->
<!-- ggplot(dr_assert) + geom_bar(aes(x = assertion_label, y = count, -->
<!--                                  fill = uid), -->
<!--                              stat = "identity", position = "dodge", -->
<!--                              width = 2/3) + -->
<!--   theme(axis.text.x = element_text(size = 7)) +  -->
<!--   labs(x = "Assertions") -->
<!-- ``` -->

<!-- ### Example 6: Retrieve assertion information for datasets -->
<!-- Compare data quality metrics for data resources -->
<!-- ```{r} -->
<!-- dr <- data_resources(druid = c('dr1411','dr90','dr361'), extra = 'assertions') -->
<!-- ``` -->

<!-- ```{r eval = FALSE} -->
<!-- # View names of all columns returned -->
<!-- names(dr) -->
<!-- ``` -->

<!-- Extract the assertion metrics from the dataset -->
<!-- ```{r warning = FALSE} -->
<!-- library(tidyr) -->
<!-- # match cols against known assertions -->
<!-- assertions <- ala_fields('assertions') -->
<!-- assert_match <- names(dr)[names(dr) %in% assertions$name] -->
<!-- dr_assert <- dr %>% select(uid, all_of(assert_match)) %>% -->
<!--   pivot_longer(-uid, names_to = "assertion", values_to = "count") %>% -->
<!--   mutate(count = as.integer(trimws(as.character(count)))) %>% -->
<!--   # build axes labels with readable assertions -->
<!--   mutate(assertion_label = tolower(gsub('([A-Z])','\n\\1',assertion))) -->
<!-- ``` -->

<!-- Plot the assertions -->
<!-- ```{r warning=FALSE} -->
<!-- library(ggplot2) -->
<!-- ggplot(dr_assert) + geom_bar(aes(x = assertion_label, y = count, -->
<!--                                  fill = uid), -->
<!--                              stat = "identity", position = "dodge", -->
<!--                              width = 2/3) + -->
<!--   theme(axis.text.x = element_text(size = 7)) +  -->
<!--   labs(x = "Assertions") -->
<!-- ``` -->
